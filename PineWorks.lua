local a,b=term.getSize()local c=window.create(term.current(),1,1,a,b)local d=term.redirect(c)local e=require("Pine3D")local f=true;local g={}g.isDown={}local h=g.isDown;g.scenes={}local i=e.newFrame()g.frame=i;g.selectedScene=nil;g.modelGen=e.models;g.effects={}g.effects.shrink=function(j,k,l)if l>0.5 then return true end;local m=j.pineObject[7]for n=1,#m do local o=m[n]for p=1,9 do o[p]=o[p]*0.5^(k*20)end end end;local function q(r)end;g.log=q;local function s()if periphemu then periphemu.create("PW:log","monitor")local t=peripheral.wrap("PW:log")function q(r)if type(r)=="table"then r=textutils.serialise(r)elseif type(r)=="function"then r="function"elseif type(r)=="nil"then r="nil"else r=tostring(r)end;local u=term.redirect(t)print(r)term.redirect(u)end;g.log=q end;q("[Booting PW]\nUse PW.log() for logging")end;local v={}local function w()local x,y,z,A=peripheral.find("speaker",function(B,C)return true end)if x then v[#v+1]=x end;if y then v[#v+1]=y end;if z then v[#v+1]=z end;if A then v[#v+1]=A end;if#v<=0 and periphemu then periphemu.create("left","speaker")periphemu.create("right","speaker")periphemu.create("top","speaker")periphemu.create("bottom","speaker")x,y,z,A=peripheral.find("speaker",function(B,C)return true end)if x then v[#v+1]=x end;if y then v[#v+1]=y end;if z then v[#v+1]=z end;if A then v[#v+1]=A end end end;w()local D=1;g.audio={}g.audio.playNote=function(E,F,G)if#v<=0 then return end;D=D%#v+1;local H=v[D]return H.playNote(E,F,G)end;function g.model(I,J)local m=e.loadModel(I)if not J or not J.skipNormalize then m=m:center():alignBottom():normalizeScaleY()end;return m end;local function K(L,M,N,O,P,Q,R,S,T,z)local o={x1=L,y1=M,z1=N,x2=O,y2=P,z2=Q,x3=R,y3=S,z3=T,c=z}return o end;local function U(m,o)m[#m+1]=o end;g.meshBuilders={}g.meshBuilders.floorTiles=function()local V={grid={}}function V:addTile(r,W,X)if not self.grid[r]then self.grid[r]={}end;self.grid[r][W]=X or colors.red end;function V:buildModel()local m={}for r,x in pairs(self.grid)do for Y,X in pairs(x)do U(m,K(r-0.5,0,Y-0.5,r+0.5,0,Y+0.5,r+0.5,0,Y-0.5,X))U(m,K(r-0.5,0,Y-0.5,r-0.5,0,Y+0.5,r+0.5,0,Y+0.5,X))end end;for B,Z in pairs(e.transforms)do m[B]=Z end;return m end;return V end;g.meshBuilders.floorTilesSmooth=function()local V={grid={}}function V:addTile(r,W,X)if not self.grid[r]then self.grid[r]={}end;self.grid[r][W]=X or colors.red end;function V:buildModel()local m={}local function _(r,W)return self.grid[r]and self.grid[r][W]end;for r,x in pairs(self.grid)do for Y,X in pairs(x)do if _(r-1,Y)and _(r+1,Y)or _(r,Y-1)and _(r,Y+1)then U(m,K(r-0.5,0,Y-0.5,r+0.5,0,Y+0.5,r+0.5,0,Y-0.5,X))U(m,K(r-0.5,0,Y-0.5,r-0.5,0,Y+0.5,r+0.5,0,Y+0.5,X))elseif _(r+1,Y)and _(r,Y-1)then U(m,K(r-0.5,0,Y-0.5,r+0.5,0,Y+0.5,r+0.5,0,Y-0.5,X))elseif _(r-1,Y)and _(r,Y+1)then U(m,K(r-0.5,0,Y-0.5,r-0.5,0,Y+0.5,r+0.5,0,Y+0.5,X))elseif _(r+1,Y)and _(r,Y+1)then U(m,K(r-0.5,0,Y+0.5,r+0.5,0,Y+0.5,r+0.5,0,Y-0.5,X))elseif _(r-1,Y)and _(r,Y-1)then U(m,K(r-0.5,0,Y+0.5,r+0.5,0,Y-0.5,r-0.5,0,Y-0.5,X))end end end;for B,Z in pairs(e.transforms)do m[B]=Z end;return m end;return V end;g.meshBuilders.cube2d=function()local V={grid={}}function V:addCube(r,W,a0)if not self.grid[r]then self.grid[r]={}end;self.grid[r][W]=a0 end;function V:buildModel()local m={}local function _(r,W)return self.grid[r]and self.grid[r][W]end;for r,x in pairs(self.grid)do for Y,a0 in pairs(x)do local X=colors.red;if type(a0=="number")then X=a0 end;local a1=X;local a2=X;local a3=X;local a4=X;local a5=nil;local a6=nil;if type(a0)=="table"then a1=a0.x or a0.xPos or X;a2=a0.z or a0.zPos or X;a3=a0.x or a0.xNeg or X;a4=a0.z or a0.zNeg or X;a5=a0.y or a0.yPos;a6=a0.y or a0.yNeg end;if not _(r,Y+1)then U(m,K(r-0.5,0,Y+0.5,r+0.5,0,Y+0.5,r+0.5,1,Y+0.5,a2))U(m,K(r-0.5,0,Y+0.5,r+0.5,1,Y+0.5,r-0.5,1,Y+0.5,a2))end;if not _(r,Y-1)then U(m,K(r-0.5,0,Y-0.5,r+0.5,1,Y-0.5,r+0.5,0,Y-0.5,a4))U(m,K(r-0.5,0,Y-0.5,r-0.5,1,Y-0.5,r+0.5,1,Y-0.5,a4))end;if not _(r-1,Y)then U(m,K(r-0.5,0,Y-0.5,r-0.5,0,Y+0.5,r-0.5,1,Y+0.5,a3))U(m,K(r-0.5,0,Y-0.5,r-0.5,1,Y+0.5,r-0.5,1,Y-0.5,a3))end;if not _(r+1,Y)then U(m,K(r+0.5,0,Y-0.5,r+0.5,1,Y+0.5,r+0.5,0,Y+0.5,a1))U(m,K(r+0.5,0,Y-0.5,r+0.5,1,Y-0.5,r+0.5,1,Y+0.5,a1))end;if a5 then U(m,K(r-0.5,1,Y-0.5,r+0.5,1,Y+0.5,r+0.5,1,Y-0.5,a5))U(m,K(r-0.5,1,Y-0.5,r-0.5,1,Y+0.5,r+0.5,1,Y+0.5,a5))end;if a6 then U(m,K(r-0.5,0,Y-0.5,r+0.5,0,Y-0.5,r+0.5,0,Y+0.5,a6))U(m,K(r-0.5,0,Y-0.5,r+0.5,0,Y+0.5,r-0.5,0,Y+0.5,a6))end end end;for B,Z in pairs(e.transforms)do m[B]=Z end;return m end;return V end;g.meshBuilders.cube3d=function()local V={grid={}}function V:addCube(r,W,Y,a0)if not self.grid[r]then self.grid[r]={}end;if not self.grid[r][W]then self.grid[r][W]={}end;self.grid[r][W][Y]=a0 end;function V:buildModel()local m={}local function _(r,W,Y)return self.grid[r]and self.grid[r][W]and self.grid[r][W][Y]end;for r,x in pairs(self.grid)do for W,y in pairs(x)do for Y,a0 in pairs(y)do local X=colors.red;if type(a0=="number")then X=a0 end;local a1=X;local a2=X;local a3=X;local a4=X;local a5=X;local a6=X;if type(a0)=="table"then a1=a0.x or a0.xPos or X;a2=a0.z or a0.zPos or X;a3=a0.x or a0.xNeg or X;a4=a0.z or a0.zNeg or X;a5=a0.y or a0.yPos or X;a6=a0.y or a0.yNeg or X end;if not _(r,W,Y+1)then U(m,K(r-0.5,W,Y+0.5,r+0.5,W,Y+0.5,r+0.5,W+1,Y+0.5,a2))U(m,K(r-0.5,W,Y+0.5,r+0.5,W+1,Y+0.5,r-0.5,W+1,Y+0.5,a2))end;if not _(r,W,Y-1)then U(m,K(r-0.5,W,Y-0.5,r+0.5,W+1,Y-0.5,r+0.5,W,Y-0.5,a4))U(m,K(r-0.5,W,Y-0.5,r-0.5,W+1,Y-0.5,r+0.5,W+1,Y-0.5,a4))end;if not _(r-1,W,Y)then U(m,K(r-0.5,W,Y-0.5,r-0.5,W,Y+0.5,r-0.5,W+1,Y+0.5,a3))U(m,K(r-0.5,W,Y-0.5,r-0.5,W+1,Y+0.5,r-0.5,W+1,Y-0.5,a3))end;if not _(r+1,W,Y)then U(m,K(r+0.5,W,Y-0.5,r+0.5,W+1,Y+0.5,r+0.5,W,Y+0.5,a1))U(m,K(r+0.5,W,Y-0.5,r+0.5,W+1,Y-0.5,r+0.5,W+1,Y+0.5,a1))end;if not _(r,W+1,Y)then U(m,K(r-0.5,W+1,Y-0.5,r+0.5,W+1,Y+0.5,r+0.5,W+1,Y-0.5,a5))U(m,K(r-0.5,W+1,Y-0.5,r-0.5,W+1,Y+0.5,r+0.5,W+1,Y+0.5,a5))end;if not _(r,W-1,Y)then U(m,K(r-0.5,W,Y-0.5,r+0.5,W,Y-0.5,r+0.5,W,Y+0.5,a6))U(m,K(r-0.5,W,Y-0.5,r+0.5,W,Y+0.5,r-0.5,W,Y+0.5,a6))end end end end;for B,Z in pairs(e.transforms)do m[B]=Z end;return m end;return V end;g.loaders={}g.loaders.fromNFP=function(a7,I,a8)local a9=paintutils.loadImage(I)or{}local function _(r,W)return a9[W]and a9[W][r]end;for W,aa in pairs(a9)do for r,X in pairs(aa)do if type(a8)=="function"then if X>0 then a8(r,W,X,_)end else local ab=a8[X]if type(ab)=="function"then ab(r,W,X,_)elseif ab then a7:add(ab,r,0,W)end end end end end;function g.selectScene(a7)if type(a7)=="string"then g.selectedScene=a7 else g.selectedScene=a7.id end end;g.vehicle=function(j,ac)local ad=math.pi;local ae=2;local af={x=j.x,y=j.y,z=j.z,speed=0,angle=j.rotY or 0,object=j,config={speedMultiplier=(ac or{}).speedMultiplier or 1,turnSpeedMultiplier=(ac or{}).turnSpeedMultiplier or 1,dragMultiplier=(ac or{}).dragMultiplier or 1,maxSpeed=(ac or{}).maxSpeed or nil}}local ac=af.config;local function ag()if af.speed>=0 then return 1 end;return-1 end;function af:turnLeft(k)local ah=math.abs(self.speed)local ai=ah;local aj=(ai/(ai+1)*40+ai)*0.01*ac.turnSpeedMultiplier;self.angle=self.angle+ag()*aj*ad*k end;function af:turnRight(k)local ah=math.abs(self.speed)local ai=ah;local aj=(ai/(ai+1)*40+ai)*0.01*ac.turnSpeedMultiplier;self.angle=self.angle-ag()*aj*ad*k end;function af:throttle(k)self.speed=self.speed+ae*k*ac.speedMultiplier end;function af:reverse(k)self.speed=self.speed-ae*k*ac.speedMultiplier end;function af:update(k)local ak=self.angle+math.pi*0.5;self.x=self.x+math.sin(ak)*self.speed*k;self.z=self.z+math.cos(ak)*self.speed*k;self.speed=self.speed*math.pow(0.8,k*ac.dragMultiplier)if ac.maxSpeed~=nil then if self.speed>ac.maxSpeed then self.speed=ac.maxSpeed elseif self.speed<-ac.maxSpeed then self.speed=-ac.maxSpeed end end;self.object:setPos(self.x,self.y,self.z,0,self.angle,0)end;function af:setPos(r,W,Y,ak)self.x=r or self.x;self.y=W or self.y;self.z=Y or self.z;self.angle=ak or self.angle end;j:on("update",function(k)if h[keys.w]or h[keys.up]then af:throttle(k)end;if h[keys.s]or h[keys.down]then af:reverse(k)end;local al=h[keys.a]or h[keys.left]local am=h[keys.d]or h[keys.right]if al and not am then af:turnLeft(k)end;if am and not al then af:turnRight(k)end;af:update(k)end)return af end;g.cameraControllers={}g.cameraControllers.none=function()local an={camera=nil}function an:setCamera(ao)end;function an:update(k)end;return an end;g.cameraControllers.keyboard=function(ap,ad,aq)local ap=ap or 5;local ad=ad or 180;local ar=not aq or not aq.disableFlight;local an={}function an:setCamera(ao)an.camera=ao end;local as=math.sin;local at=math.cos;local au=math.min;local av=math.max;local aw=math.rad;function an:update(k)local ax,ay,az=0,0,0;local ao=self.camera;if not ao then return end;if h[keys.left]then ao.rotY=(ao.rotY-ad*k)%360 end;if h[keys.right]then ao.rotY=(ao.rotY+ad*k)%360 end;if h[keys.down]then ao.rotZ=av(-80,ao.rotZ-ad*k)end;if h[keys.up]then ao.rotZ=au(80,ao.rotZ+ad*k)end;if h[keys.w]then ax=ap*at(aw(ao.rotY))+ax;az=ap*as(aw(ao.rotY))+az end;if h[keys.s]then ax=-ap*at(aw(ao.rotY))+ax;az=-ap*as(aw(ao.rotY))+az end;if h[keys.a]then ax=ap*at(aw(ao.rotY-90))+ax;az=ap*as(aw(ao.rotY-90))+az end;if h[keys.d]then ax=ap*at(aw(ao.rotY+90))+ax;az=ap*as(aw(ao.rotY+90))+az end;if ar then if h[keys.space]then ay=ap+ay end;if h[keys.leftShift]then ay=-ap+ay end end;ao.x=ao.x+ax*k;ao.y=ao.y+ay*k;ao.z=ao.z+az*k end;return an end;g.cameraControllers.follow=function(aA)local an={}function an:setCamera(ao)an.camera=ao end;local aB=(aA or{}).offsetVertical or 2;local aC=(aA or{}).offsetHorizontal or-3;local aD=(aA or{}).downAngle or-20;local aE=(aA or{}).smoothing or 0.01;local aF;function an:setTarget(j)aF=j end;function an:update(k)local ao=self.camera;if not ao then return end;local aG=aF.x;local aH=aF.y+aB;local aI=aF.z;local aJ=(aF.rotY or 0)+math.pi*0.5;aG=aG+math.sin(aJ)*aC;aI=aI+math.cos(aJ)*aC;local a=math.pow(aE,k)local aK=ao.x*a+aG*(1-a)local aL=ao.y*a+aH*(1-a)local aM=ao.z*a+aI*(1-a)local aN=-math.deg(aJ-math.pi*0.5)local aO=ao.rotY*a+aN*(1-a)ao:setPos(aK,aL,aM,nil,aO,aD)end;return an end;local function aP()local ao={x=0,y=0,z=0,rotX=0,rotY=0,rotZ=0,controller=g.cameraControllers.none()}function ao:setPos(r,W,Y,aQ,aR,aS)self.x=r or self.x;self.y=W or self.y;self.z=Y or self.z;self.rotX=aQ or self.rotX;self.rotY=aR or self.rotY;self.rotZ=aS or self.rotZ end;function ao:setController(an)self.controller=an;an:setCamera(self)end;return ao end;local function aT()local aU={elements={}}function aU:clear()aU.elements={}end;function aU:addText(aV,r,W,aW,aX)local aY=window.create(term.current(),r,W,#aV,1,false)aY.setTextColor(aW or colors.white)aY.setBackgroundColor(aX or colors.black)aY.write(aV)local aZ={id="text",str=aV,x=r,y=W,win=aY}function aZ:setStr(aV)self.str=aV;aY.reposition(r,W,#aV,1)aY.setCursorPos(1,1)aY.write(aV)end;function aZ:setPos(r,W)self.x=r;self.y=W;aY.reposition(r,W,#self.str,1)end;aU.elements[#aU.elements+1]=aZ;return aZ end;function aU:addWindow(r,W,a_,b0)local aY=window.create(term.current(),r,W,a_,b0,false)aY.setTextColor(colors.white)aY.setBackgroundColor(colors.black)aY.clear()local window={win=aY}aU.elements[#aU.elements+1]=window;return window end;function aU:render()local aY=i.buffer.blittleWindow;for n=1,#aU.elements do local b1=aU.elements[n]b1.win.setVisible(false)b1.win.setVisible(true)end end;return aU end;function g.newScene(b2)b2=b2 or"scene_"..#g.scenes;local a7={id=b2,objects={},objectsEffects={},objectsPine={},envObjects={},envObjectsPine={},camera=aP()}function a7:clearObjects()self.objects={}self.objectsEffects={}self.objectsPine={}end;function a7:clearEnvironment()self.envObjects={}self.envObjectsPine={}end;function a7:add(m,r,W,Y,aQ,aR,aS)if type(m)=="string"then m=g.model(m)end;local b3=i:newObject(m,r,W,Y,aQ,aR,aS)a7.objectsPine[#a7.objectsPine+1]=b3;local j={pineObject=b3,x=r,y=W,z=Y,rotX=aQ,rotY=aR,rotZ=aS,eventHandlers={}}a7.objects[#a7.objects+1]=j;function j:setPos(r,W,Y,aQ,aR,aS)self.x=r or self.x;self.y=W or self.y;self.z=Y or self.z;self.rotX=aQ or self.rotX;self.rotY=aR or self.rotY;self.rotZ=aS or self.rotZ;b3:setPos(r,W,Y)b3:setRot(aQ,aR,aS)end;j.collision={}function j.collision:withinXZ(b4)local function ag(L,M,O,P,R,S)return(L-R)*(P-S)-(O-R)*(M-S)end;local function b5(b6,b7,L,M,O,P,R,S)local b8=ag(b6,b7,L,M,O,P)<0;local b9=ag(b6,b7,O,P,R,S)<0;local ba=ag(b6,b7,R,S,L,M)<0;return b8==b9 and b9==ba end;local bb=b4.pineObject[7]for n=1,#bb do local bc=bb[n]if b5(j.x,j.z,bc[1],bc[3],bc[4],bc[6],bc[7],bc[9])then return true end end end;function j:on(bd,be)self.eventHandlers[bd]=be end;local function bf()for n=1,#a7.objects do local bg=a7.objects[n]if bg==self then table.remove(a7.objects,n)break end end end;local function bh()for n=1,#a7.objectsPine do local bg=a7.objectsPine[n]if bg==j.pineObject then table.remove(a7.objectsPine,n)break end end end;function j:remove(bi)if bi==nil then bh()bf()else local bj=0;self:on("update",function(k)bj=bj+k;for n=1,#bi do local bk=bi[n](j,k,bj)if bk then bh()bf()return end end end)end end;return j end;function a7:addEnv(m,r,W,Y)if type(m)=="string"then m=g.model(m)end;local b3=i:newObject(m,r,W,Y)a7.envObjectsPine[#a7.envObjectsPine+1]=b3;local j={pineObject=b3,eventHandlers={}}a7.envObjects[#a7.envObjects+1]=j;function j:on(bd,be)self.eventHandlers[bd]=be end;function j:setPos(r,W,Y,aQ,aR,aS)b3:setPos(r,W,Y)b3:setRot(aQ,aR,aS)end;return j end;a7.hud=aT()a7.eventHandlers={}function a7:on(bd,be)a7.eventHandlers[bd]=be end;g.scenes[b2]=a7;if f then g.selectScene(b2)f=false end;return a7 end;function g.run(J)if not J or not J.disableDebug then s()end;local function bl()while true do local bd,bm,bn,bo=os.pullEvent()local a7=g.scenes[g.selectedScene]if bd=="key"then h[bm]=true;if a7.eventHandlers["key"]then a7.eventHandlers["key"](bm)end elseif bd=="key_up"then h[bm]=nil;if a7.eventHandlers["key_up"]then a7.eventHandlers["key_up"](bm)end elseif bd=="mouse_drag"then if a7.eventHandlers["mouse_drag"]then a7.eventHandlers["mouse_drag"](bm,bn,bo)end elseif bd=="mouse_click"then if a7.eventHandlers["mouse_click"]then a7.eventHandlers["mouse_click"](bm,bn,bo)end elseif bd=="mouse_scroll"then if a7.eventHandlers["mouse_scroll"]then a7.eventHandlers["mouse_scroll"](bm,bn,bo)end elseif bd=="term_resize"then local a,b=d.getSize()c.reposition(1,1,a,b)i:setSize(1,1,a,b)end end end;local function bp()local bq=os.epoch("utc")while true do local br=os.epoch("utc")local k=(br-bq)/1000;bq=br;k=math.min(k,0.1)local a7=g.scenes[g.selectedScene]if a7 then if a7.eventHandlers["update"]then a7.eventHandlers["update"](k)end;if a7.camera.controller then a7.camera.controller:update(k)end;for n=1,#a7.objects do local b4=a7.objects[n]if b4.eventHandlers["update"]then b4.eventHandlers["update"](k)end end;for n=1,#a7.envObjects do local b4=a7.envObjects[n]if b4.eventHandlers["update"]then b4.eventHandlers["update"](k)end end;i:setCamera(a7.camera)i:drawObjects(a7.envObjectsPine)i:drawObjects(a7.objectsPine)i:drawBuffer()a7.hud:render()c.setVisible(true)c.setVisible(false)end;os.queueEvent("fake_event")os.pullEvent("fake_event")end end;local function bs()parallel.waitForAny(bl,bp)end;local bt,bu=pcall(bs)if not bt then term.redirect(d)term.setBackgroundColor(colors.black)term.setTextColor(colors.red)term.clear()term.setCursorPos(1,1)print(bu)end end;return g